<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Конвертер KEY ↔ REF с графиком</title>
<style>
  body {
    font-family: 'Segoe UI', sans-serif;
    background: #f0f2f5;
    color: #333;
    max-width: 960px;
    margin: 30px auto;
    padding: 20px;
  }
  h1 { text-align: center; color: #2c3e50; }
  .flex { display: flex; gap: 20px; flex-wrap: wrap; }
  .box {
    background: #fff;
    padding: 16px;
    border-radius: 8px;
    flex: 1 1 300px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
  }
  label { font-weight: bold; display: block; margin-top: 12px; }
  input, select, button {
    width: 100%;
    padding: 8px;
    margin-top: 6px;
    font-size: 1rem;
    border-radius: 5px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    transition: border-color .3s;
  }
  input:focus, select:focus { border-color: #3498db; outline: none; }
  button { background: #3498db; color: white; border: none; cursor: pointer; font-weight: bold; }
  button:hover { background: #2980b9; }
  #history { margin-top: 20px; }
  #history-header { display: flex; justify-content: space-between; align-items: center; }
  #history li { padding: 6px 10px; border-bottom: 1px solid #eee; cursor: pointer; }
  #history li:hover { background: #e8f5fc; }
  #notification {
    position: fixed;
    top: 20px; right: 20px;
    background: #2ecc71;
    color: white;
    padding: 12px 20px;
    border-radius: 5px;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity .3s, transform .3s;
  }
  #notification.show { opacity: 1; transform: translateY(0); }
  canvas { max-width: 100%; }
</style>
</head>
<body>
  <h1>Конвертер KEY ↔ REF</h1>

  <div class="flex">
    <div class="box">
      <label>Сумма</label>
      <input type="number" id="amountFrom" step="0.0001" placeholder="Введите сумму" />

      <label>Из</label>
      <select id="curFrom">
        <option value="key">KEY</option>
        <option value="ref">REF</option>
      </select>

      <label>В</label>
      <select id="curTo">
        <option value="ref">REF</option>
        <option value="key">KEY</option>
      </select>

      <button id="swapBtn">Поменять местами</button>

      <ul id="history">
        <div id="history-header">
          <strong>История:</strong>
          <button id="clearHistory">Очистить</button>
        </div>
      </ul>
    </div>

    <div class="box">
      <canvas id="chart" height="200"></canvas>
      <small>График курса (KEY → REF), обновляется каждые 5 минут</small>
    </div>
  </div>

  <div id="notification"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(async () => {
  const API_KEY = '68a1d6d01326fe092a02c00c';
  const historyKey = 'conv_history';
  const chartKey = 'chart_data';

  const amountFrom = document.getElementById('amountFrom');
  const curFrom = document.getElementById('curFrom');
  const curTo = document.getElementById('curTo');
  const swapBtn = document.getElementById('swapBtn');
  const historyEl = document.getElementById('history');
  const clearBtn = document.getElementById('clearHistory');
  const notification = document.getElementById('notification');

  let rates = { keyToRef: null }; // курс ключа в реф
  let history = JSON.parse(localStorage.getItem(historyKey)) || [];
  let chartData = JSON.parse(localStorage.getItem(chartKey)) || { labels: [], data: [] };

  const ctx = document.getElementById('chart').getContext('2d');
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData.labels.map(ts => new Date(ts)),
      datasets: [{
        label: 'KEY → REF',
        data: chartData.data,
        borderColor: '#e74c3c',
        backgroundColor: 'rgba(231,76,60,0.2)',
        fill: true,
        tension: 0.2
      }]
    },
    options: {
      scales: {
        x: { type: 'time', time: { unit: 'minute' } },
        y: { beginAtZero: false }
      }
    }
  });

  function showMsg(msg, isError = false) {
    notification.textContent = msg;
    notification.style.background = isError ? '#e74c3c' : '#2ecc71';
    notification.classList.add('show');
    setTimeout(() => notification.classList.remove('show'), 4000);
  }

  function saveHistory() {
    localStorage.setItem(historyKey, JSON.stringify(history));
  }
  function renderHistory() {
    historyEl.querySelectorAll('li').forEach(li => li.remove());
    history.forEach((h, i) => {
      const li = document.createElement('li');
      li.textContent = `${h.fromAmount} ${h.fromCur} → ${h.toAmount} ${h.toCur} (${new Date(h.time).toLocaleTimeString()})`;
      li.onclick = () => {
        amountFrom.value = h.fromAmount;
        curFrom.value = h.fromCur;
        curTo.value = h.toCur;
        convert();
      };
      historyEl.appendChild(li);
    });
  }

  function saveChartPoint(rate) {
    const ts = Date.now();
    chartData.labels.push(ts);
    chartData.data.push(rate);
    if (chartData.labels.length > 60) {
      chartData.labels.shift(); chartData.data.shift();
    }
    localStorage.setItem(chartKey, JSON.stringify(chartData));
    chart.data.labels = chartData.labels.map(ts => new Date(ts));
    chart.data.datasets[0].data = chartData.data;
    chart.update();
  }

  async function fetchKeyPrice() {
    try {
      const url = 'https://backpack.tf/api/IGetPriceHistory/v1?appid=440&item=' +
        encodeURIComponent('Mann Co. Supply Crate Key') +
        '&quality=Unique&tradable=Tradable&craftable=Craftable&priceindex=0&key=' + API_KEY;
      const res = await fetch(url);
      if(!res.ok) throw new Error('Network error');
      const json = await res.json();
      console.log('bp.tf history:', json);
      const prices = json.response?.prices;
      if (!prices?.length) throw new Error('No price data');
      const last = prices[prices.length -1];
      rates.keyToRef = last.value;
      console.log('Current KEY→REF:', rates.keyToRef);
    } catch(e) {
      showMsg(e.message, true);
      console.error(e);
    }
  }

  function convert() {
    const amt = parseFloat(amountFrom.value);
    if (!rates.keyToRef || isNaN(amt) || amt <= 0) return;
    let output;
    if (curFrom.value === 'key' && curTo.value === 'ref') {
      output = amt * rates.keyToRef;
    } else if (curFrom.value === 'ref' && curTo.value === 'key') {
      output = amt / rates.keyToRef;
    }
    if (output != null) {
      amountFrom.value = amt.toFixed(4);
      // result shown in same input for simplicity:
      amountFrom.value = amt;
      amountFrom.blur();
      saveHistory();
      renderHistory();
      amountFrom.value = '';
    }
  }

  swapBtn.onclick = () => {
    [curFrom.value, curTo.value] = [curTo.value, curFrom.value];
    convert();
  };

  clearBtn.onclick = () => {
    if(confirm('Очистить историю?')) {
      history = [];
      saveHistory();
      renderHistory();
      showMsg('История очищена');
    }
  };

  amountFrom.addEventListener('input', debounce(convert, 300));
  curFrom.addEventListener('change', convert);
  curTo.addEventListener('change', convert);

  async function updateAll() {
    await fetchKeyPrice();
    if (rates.keyToRef) {
      saveChartPoint(rates.keyToRef);
      showMsg('Курс обновлён: 1 Key = ' + rates.keyToRef.toFixed(3) + ' Ref');
      convert();
    }
  }

  await updateAll();
  renderHistory();
  setInterval(updateAll, 5 * 60 * 1000);

  function debounce(fn, delay) {
    let t;
    return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); };
  }
})();
</script>
</body>
</html>
